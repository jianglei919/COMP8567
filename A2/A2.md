./ptree26w root_process process_id -cnt
./ptree26w rootPID targetPID -mmd

root_process：比如 sampletree 的主进程 PID（或者 bash 下某个你想当根的 PID）
process_id：选 root 的某个后代 PID

0. 默认功能（无 option）

**目标：**判断 process_id 是否在 root_process 子树里；是就输出 PID + PPID。
• 需要：构建子树（扫描 /proc + PPID）
• 输出 PPID：读 /proc/<process_id>/stat 或 /status 的 PPid

统计/查询类

-cnt：后代总数
• 做法：从 process_id DFS/BFS，数所有后代节点数量（不含自己）

-oct：孤儿进程数量
• “孤儿”通常指 父进程已经不在你的子树里/或父变成 1（按老师定义，可能是 PPID=1 或父不在 root 子树）
• 需要：每个后代的 PPID（stat/status）
• 做法：遍历后代，对每个 pid 检查它的 PPID 是否在你的树内；不在则算孤儿（或 PPID==1）

-odt：最老后代（PID + 创建时间）
• 需要：/proc/<pid>/stat 的 starttime
• 做法：遍历后代，取 starttime 最小的那个（最早启动）

-ndt：最新后代（PID）
• 需要：starttime
• 做法：遍历后代，取 starttime 最大的那个

-dnd：非直接后代数量
• “direct children” 是孩子；“non-direct” 是孙子及更深
• 做法：
• 先拿 process_id 的 direct children 数量
• 再拿 total descendants
• non-direct = total - direct

-mmd：VmRSS 最大的后代（并列都输出）
• 需要：/proc/<pid>/status 里的 VmRSS:
• 做法：遍历后代，读 VmRSS（没有就当 0），找最大值；把所有等于最大值的 pid 全输出

-mpd：CPU 时间最大（并列都输出）
• 需要：/proc/<pid>/stat 的 utime + stime
• 做法：对每个后代算 cpu = utime + stime，取最大；并列全输出

单位是 clock ticks，题目也允许输出 ticks。

⸻

控制/信号类

-dtm：按创建时间从新到旧杀掉后代
• 需要：starttime（用来排序），然后 kill
• 做法：
• 收集所有后代 pid + starttime
• 按 starttime 降序排序（新的先）
• 依次 kill(pid, SIGKILL)
• 同时要做安全检查：不要杀 bash、不要越权（kill 失败要提示）

-sst：给兄弟进程发 SIGSTOP
• 兄弟 = 和 process_id 同一个 PPID 的其他进程
• 需要：process_id 的 PPID（stat/status），然后找所有 pid whose PPID==that PPID
• 做法：对每个 sibling 调 kill(sib, SIGSTOP)

-sco：给处于 stop 的兄弟发 SIGCONT
• 同上先找到 siblings
• 需要额外判断状态：/proc/<sib>/stat 的 state == 'T'，或 /status 的 State: T
• 只对 stopped 的发 kill(sib, SIGCONT)

⸻

kill 类（都要求 SIGKILL，且不能 kill bash）

这些都需要先“定位目标 pid 集合”，再逐个 kill(pid, SIGKILL)。

-kpp：kill 父进程
• 取 process_id 的 PPID → kill(PPID)

-kgp：kill 祖父
• PPID = parent
• 再读 parent 的 PPID → grandparent → kill

-ksp：kill 所有兄弟
• 找 siblings（同 PPID）→ kill

-kps：kill “父进程的兄弟”（叔叔伯伯）
• parent = PPID(process_id)
• grandparent = PPID(parent)
• parent_siblings = all pid whose PPID==grandparent AND pid != parent
• kill those

-kcp：kill 所有孩子
• children(process_id) → kill each

-kgc：kill 所有孙子
• 对每个 child，取 children(child)，合起来就是 grand-children → kill

-krp：kill root_process
• kill(root_process)

bash 检测（简单做法）：读 /proc/<pid>/comm 或 /proc/<pid>/status 的 Name:，如果是 bash 就拒绝。

⸻

额外命令（不带参数）

-bcp：当前 bash 下的进程总数（不含 bash 自己）
• 核心：你需要先找到“当前 bash 的 PID”（可以用 getppid()，因为你的程序是从 bash 启动的）
• 然后：构建以 bash_pid 为 root 的子树，数后代数量

-bop：所有打开的 bash 终端进程总数（不含 bash 自己）
• 做法：扫描 /proc 找所有 bash 进程 pid
• 对每个 bash_pid，数它的后代数量（不含 bash 本身）
• 全部加起来
